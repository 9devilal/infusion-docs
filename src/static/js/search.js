/* globals lunr */
(function (fluid) {
    "use strict";
    fluid.registerNamespace("fluid.docs.search");

    /**
     * Process the pre-generated index created using src/scripts/create-search-digest.js.
     *
     * @param {Object} that - The search component itself.
     *
     */
    fluid.docs.search.processDigest = function (that) {
        var preIndexTime = Date.now();

        that.index = lunr.Index.load(fluid.docs.search.index);

        fluid.log("Loaded index in " + (Date.now() - preIndexTime) + " ms");

        // Initial state might have been relayed from the location bar by now.
        if (that.model.qs) {
            that.search();
        }
    };

    /**
     *
     * Search for the query string, then issue a call to display the results.  The raw results generated by Lunr.js are
     * grouped by page and ordered by the most relevant result for each individual page.
     *
     * @param {Object} that - The search component itself.
     *
     */
    fluid.docs.search.performSearch = function (that) {
        if (that.model.qs && that.model.qs.length && that.index) {
            var preSearchTime = Date.now();

            var hasSearchWeighting = that.model.qs.match(/[\+\-\"]/);
            var rawSearchResults= hasSearchWeighting ? fluid.docs.search.weightedSearch(that) : fluid.docs.search.simpleSearch(that);

            // Use a map keyed by path to check for uniqueness and group results
            var resultsByPage = {};

            // Use an array storing individual grouped path entries to preserve the search order, as in:
            var orderedResults = [];

            fluid.each(rawSearchResults, function (rawSearchResult) {
                var item = fluid.docs.search.digest[rawSearchResult.ref];
                var pageEntry = resultsByPage[item.pagePath];
                if (!pageEntry) {
                    pageEntry = {
                        pagePath:    item.pagePath,
                        pageTitle:   item.pageTitle,
                        pageResults: []
                    };
                    resultsByPage[item.pagePath] = pageEntry;
                    orderedResults.push(pageEntry);
                }

                var itemWithHighlights = fluid.docs.search.highlightItem(item, rawSearchResult.matchData);
                pageEntry.pageResults.push(itemWithHighlights);
                //pageEntry.pageResults.push(item);
            });

            fluid.docs.search.displayResults(that, orderedResults, rawSearchResults.length);
            fluid.log("Search completed in " + (Date.now() - preSearchTime) + " ms");
        }
        else {
            var resultsElement = that.locate("searchResults");
            resultsElement.html(that.options.messages.noQuery);
        }
    };

    fluid.docs.search.simpleSearch = function (that) {
        var results = that.index.search(that.model.qs);
        return results;
    };

    fluid.docs.search.weightedSearch = function (that) {
        var parsedSearchString = fluid.docs.search.parseSearchString(that.model.qs);

        var results = that.index.query(function (query) {
            // TODO: Require the whole phrase rather than all the individual words
            if (parsedSearchString.mustContainPhrases.length) {
                query.term(lunr.tokenizer(parsedSearchString.mustContainPhrases), { presence: lunr.Query.presence.REQUIRED });
            }

            if (parsedSearchString.mustContainWords.length) {
                query.term(lunr.tokenizer(parsedSearchString.mustContainWords), { presence: lunr.Query.presence.REQUIRED });
            }

            // TODO: Filter to the phrase rather than all the individual words.
            if (parsedSearchString.mayContainPhrases) {
                query.term(lunr.tokenizer(parsedSearchString.mayContainPhrases), { presence: lunr.Query.presence.OPTIONAL });
            }

            if (parsedSearchString.mayContainWords.length) {
                query.term(lunr.tokenizer(parsedSearchString.mayContainWords), { presence: lunr.Query.presence.OPTIONAL });
            }

            // TODO: exclude the phrase rather than all the individual words.
            if(parsedSearchString.mustNotContainPhrases) {
                query.term(lunr.tokenizer(parsedSearchString.mustNotContainPhrases), { presence: lunr.Query.presence.PROHIBITED });
            };

            if(parsedSearchString.mustNotContainWords) {
                query.term(lunr.tokenizer(parsedSearchString.mustNotContainWords), { presence: lunr.Query.presence.PROHIBITED });
            };
        });

        return results;
    };

    /**
     * @typedef searchHit - A single "search hit".
     * @property {String} body - A trimmed and highlighted representation of the longest match in this "hit" in context.
     * @property {String} headingId - If the search is associated with a linkable subheading, its ID (used for deep linking).
     * @property {String} headingText - If the search is associated with a linkable subheading, its text, otherwise the page title.
     * @property {String} pagePath - The relative path to the page within the site.
     * @property {String} pageTitle - The page's title.
     *
     * @typedef pageHits - A grouping of search hits on a single page.
     * @property {String} pagePath - The relative path to the page within the site.
     * @property {Array<searchHit>} pageResults - The full list of search hits for this page, in order of relevance.
     * @property {String} title - The page's title.
     *
     */

    /**
     *
     * Generate HTML output based on a set of search results and string templates.
     *
     * @param {Object} that - The search component itself.
     * @param {Array<pageHits>} orderedAndGroupedResults - The search results generated by `fluid.docs.search.performSearch`.
     * @param {Integer} resultsCount - The total number of individual search hits within all grouped entries.
     *
     */
    fluid.docs.search.displayResults = function (that, orderedAndGroupedResults, resultsCount) {
        var resultsElement = that.locate("searchResults");
        var htmlOutput = fluid.stringTemplate(that.options.templates.header, { pages: orderedAndGroupedResults.length, results: resultsCount });
        fluid.each(orderedAndGroupedResults, function (pageEntry) {
            var singlePageHtml = "";

            if (pageEntry.pageResults.length === 1) {
                singlePageHtml += fluid.stringTemplate(that.options.templates.pageSingleResultSummary, pageEntry.pageResults[0]);
            }
            else if (pageEntry.pageResults.length > 1) {
                var allEntriesHtml = "";
                fluid.each(pageEntry.pageResults.slice(1), function (singleResult) {
                    var singleRowHtml = fluid.stringTemplate(that.options.templates.pageItem, singleResult);
                    allEntriesHtml += singleRowHtml;
                });

                var combinedData = fluid.extend({}, pageEntry.pageResults[0], { count: (pageEntry.pageResults.length - 1), allEntries: allEntriesHtml });
                var pageSummaryHtml = fluid.stringTemplate(that.options.templates.pageMultiResultSummary, combinedData);
                singlePageHtml += pageSummaryHtml;
            }

            htmlOutput += singlePageHtml;
        });

        htmlOutput += fluid.stringTemplate(that.options.templates.footer, orderedAndGroupedResults);
        resultsElement.html(htmlOutput);

        // Adapted from: https://github.com/fluid-project/infusion/blob/master/src/framework/preferences/js/Panels.js#L147
        var userJQuery = that.container.constructor;
        that.container = userJQuery(that.container.selector, that.container.context);
        that.dom.clear();

        that.events.onRender.fire();
    };

    /**
     *
     * A wrapper to only call a given callback if desired keys (such as the space and enter keys are pressed).
     *
     * @param {Array<Integer>} activeKeys - The keys we care about.  These are jQuery key codes.
     * @param {Object} event - The jQuery event object, which contains information about the target element, key pressed, et cetera.
     * @param {Function} callback - The function to call if the user pressed one of the desired keys.
     * @param {Array} callbackArgs - Arguments to pass to the callback.
     *
     */
    fluid.docs.search.filterByKeyPress = function (activeKeys, event, callback, callbackArgs) {
        if (activeKeys.indexOf(event.keyCode) !== -1) {
            event.preventDefault();
            callback.apply(null, fluid.makeArray(callbackArgs));
        }
    };

    /**
     *
     * A function that finds the longest match within a given piece of content based on the match metadata provided by
     * Lunr.js, which looks something like:
     *
     * {
     *   "metadata": {
     *     "refer": {
     *       "body": {
     *         "position": [
     *           [ 414, 5 ],
     *           [ 891, 5 ]
     *         ]
     *       }
     *     }
     *   }
     * }
     *
     * The above contains only hits in the "body" field, there may also be "title" hits.  Using this information, all
     * title matches are highlighted.  For body content, we look for the longest match, then trim the content to the
     * nearest enclosing tag, so that we have a highlighted search hit within a relatively small piece of context
     * rather than displaying entire sections.
     *
     * @param {Object} matchingItem - The original record associated with a single "search hit".
     * @param {Object} matchData - An array of indices representing the location of search hits in context and their length.
     * @return {Object} - A copy of the matching item, with the longest match highlighted and the content trimmed to the nearest tag enclosing the longest match.
     *
     */
    fluid.docs.search.highlightItem = function (matchingItem, matchData) {
        var updatedSearchResult = fluid.copy(matchingItem);

        // Trim to the longest match for each field.
        var longestMatch = {
            headingText: {
                matchStart:  0,
                matchLength: 0,
                matchTerm:   ""
            },
            body: {
                matchStart:  0,
                matchLength: 0,
                matchTerm:   ""
            }
        };

        fluid.each(matchData.metadata, function (termMatches, term) {
            fluid.each(["headingText", "body"], function (field) {
                fluid.each(fluid.get(termMatches, [field, "position"]), function (singleMatchCoordinates) {
                    if (singleMatchCoordinates[1] > longestMatch[field].matchLength) {
                        longestMatch[field].matchStart  = singleMatchCoordinates[0];
                        longestMatch[field].matchLength = singleMatchCoordinates[1];
                        longestMatch[field].matchTerm   = term;
                    }
                });
            });
        });

        fluid.each(["headingText", "body"], function (field) {
            if (longestMatch[field].matchLength) {
                var startIndex  = longestMatch[field].matchStart;
                var endIndex    = startIndex + longestMatch[field].matchLength;
                var leader      = matchingItem[field].substring(0, startIndex);
                var toHighlight = matchingItem[field].substring(startIndex, (endIndex + 1));
                var trailer     = matchingItem[field].substring(endIndex);

                if (field === "body") {
                    // Trim the leader and trailer to the nearest enclosing tag.
                    if (longestMatch[field].matchLength) {
                        var lastTagInLeader = leader.lastIndexOf(">");
                        if (lastTagInLeader !== -1) {
                            leader = leader.substring(lastTagInLeader + 1);
                        }

                        var matchText = matchingItem.body.substring(startIndex, (endIndex + 1));

                        var firstTagInTrailer = trailer.indexOf("<");
                        if (firstTagInTrailer !== -1) {
                            trailer = trailer.substring(0, firstTagInTrailer);
                        }
                    }
                }

                updatedSearchResult[field] = leader + "<mark>" + toHighlight + "</mark>" + trailer;
            }
        });

        return updatedSearchResult;
    };

    /**
     *
     * Search results are grouped by page, and by default only the most relevant result per page is displayed.  This
     * function powers a "toggle" that can be use to expand/close the "extended results" for a given page.
     *
     * @param {Object} that - The search component itself.
     * @param {Object} event - The jQuery event object, which includes the "target element" we need.
     *
     */
    fluid.docs.search.toggleExtendedResults = function (that, event) {
        event.preventDefault();
        // Tree back out to our grandparent and look down from there.
        var containingElement = $(event.target).parent().parent();
        var extendedResultsElement = $(containingElement).find(".search-extended-results");
        extendedResultsElement.toggleClass("hidden");
    };

    // base grade without location bar, which causes problems in Testem tests.
    fluid.defaults("fluid.docs.search.base", {
        gradeNames: ["gpii.binder.bindOnCreate", "fluid.viewComponent"],
        events: {
            onRender: null
        },
        messages: {
            noQuery: "<p>Enter one or more search terms and press enter to search.</p>"
        },
        // TODO: Discuss our long term rendering strategy WRT Hugo, future Fluid, etc. and break this out better.
        templates: {
            header:     "<p>Displaying %results matching search results from %pages pages.</p>\n",
            pageMultiResultSummary: "<div class=\"search-result-single-page\"><h3><a href=\"%pagePath#%headingId\" target=\"_blank\">%pageTitle &gt; %headingText</a></h3><p class=\"search-context-highlight\">%body</p><p>Showing most relevant result, there are <a class=\"search-extended-results-toggle\" href=\"#\">%count additional entries</a> on the same page.</p> <div class=\"search-extended-results hidden\">\n%allEntries</div></div> \n",
            pageSingleResultSummary: "<div class=\"search-result-single-page\"><h3><a href=\"%pagePath#%headingId\" target=\"_blank\">%pageTitle &gt; %headingText</a></h3><p class=\"search-context-highlight\">%body</p></div> \n",
            pageItem: "<div class=\"search-result-sub-entry\"><h5><a href=\"%pagePath#%headingId\" target=\"_blank\">%pageTitle &gt; %headingText</a></h5><p class=\"search-context-highlight\">%body</p></div> \n",
            footer:     ""
        },
        selectors: {
            queryInput: ".docs-search-query",
            searchResults: ".docs-search-results",
            extendedResultsToggle: ".search-extended-results-toggle"
        },
        model: {
            qs: ""
        },
        bindings: {
            "queryInput": "qs"
        },
        members: {
            index: false
        },
        invokers: {
            search: {
                funcName: "fluid.docs.search.performSearch",
                args: ["{that}"]
            },
            toggleExtendedResults: {
                funcName: "fluid.docs.search.toggleExtendedResults",
                args: ["{that}", "{arguments}.0"] // event
            },
            toggleOnKeyPress: {
                funcName: "fluid.docs.search.filterByKeyPress",
                args: [[13, 32], "{arguments}.0", "{that}.toggleExtendedResults", ["{arguments}.0"]] // activeKeys, event, callback, callbackArgs
            }
        },
        listeners: {
            "onCreate.processDigest": {
                funcName: "fluid.docs.search.processDigest",
                args: ["{that}"]
            },

            // Toggle "extended results".
            "onRender.bindExtendedResultsToggleKeys": {
                "this": "{that}.dom.extendedResultsToggle",
                method: "keypress",
                args: ["{that}.toggleOnKeyPress"]
            },
            "onRender.bindExtendedResultsToggleClick": {
                "this": "{that}.dom.extendedResultsToggle",
                method: "click",
                args: ["{that}.toggleExtendedResults"]
            }
        },
        modelListeners: {
            "qs": {
                func: "{that}.search",
                excludeSource: "init"
            }
        }
    });

    fluid.defaults("fluid.docs.search", {
        gradeNames: ["gpii.locationBar", "fluid.docs.search.base"]
    });
})(fluid);
